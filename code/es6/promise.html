<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8">
  <title>promise</title>
</head>
<body>
  <h1>promise</h1>
  <script src="myPromise.js"></script>

  <script>
    /**
     *【翻译】Promises/A+规范
     * https://www.ituring.com.cn/article/66566#
    */
    // 自定义myPromise

    // promise的三种状态
    const PENDING = 'PENDING'
    const FULFILLED = 'FULFILLED'
    const REJECTED = 'REJECTED'

    // 解决thenable循环调用，无限调用的机制，
    // 独立抽离函数，然后递归调用
    function promiseResolveProcedure(promise2,x,resolve,reject){
      // 处理 step9
      if(promise2 === x){
        throw new Error('循环引用 promise')
      }
      // 处理promise对象
      if(x instanceof MyPromise){
        if(x.status === PENDING){
          x.then(y => {
            // resolve(y) // 如果y 也是一个theable 那么也需要递归调用
            promiseResolveProcedure(promise2,y,resolve,reject)
          },reject) // 不能漏掉了失败的返回
        }else{
          x.status === FULFILLED && resolve(x.value)
          x.status === REJECTED && reject(x.value)
        }
      }
      // 判断 thenable 对象***promise 也是一个object对象
      if((typeof x === 'object' || typeof x === 'function') && x !== null){
        if(typeof x.then === 'function'){
          x.then(y => {
            // resolve(y) // 如果y 也是一个theable 那么也需要递归调用
            promiseResolveProcedure(promise2,y,resolve,reject)
          },reject) // 不能漏掉了失败的返回
        }else{
          resolve(x)
        }
      }else{
        resolve(x)
      }
    }

    class MyPromise{

      static all(promiseArray){
        console.log(123)
        return new MyPromise((resolve,reject) => {
          const resultArray = []
          let successTimes = 0
  
          function processResult(i,data){
            resultArray[i] = data
            successTimes++
  
            if(successTimes === promiseArray.length){
              // 处理成功的
              resolve(resultArray)
            }
          }
  
          for(let i = 0; i < promiseArray.length; i++){
            promiseArray[i].then(
              data => {
                processResult(i,data)
              },
              err => {
                // 处理失败的
                reject(err)
              }
            )
          }
        })
        
      }
      constructor(fn){
        this.status = PENDING
        this.value = undefined
        this.resolvedCallbacks = []
        this.rejectCallbacks = []

        const resolve = (val) => {                 // step 10 添加的 && val.then
          if((typeof val === 'object' || typeof val === 'function') && val.then){// 处理step8
            promiseResolveProcedure(this,val,resolve,reject)
            return // 后面不再执行
          }
          setTimeout(() => { // step2 源码中添加定时器之后，可以直接使用resolve('data')
            if(this.status === PENDING){ // step3 ：如果不是pending状态进来的，就不做处理，防止多个resolve执行
              this.status = FULFILLED
              this.value = val
              // 执行所有的then方法
              this.resolvedCallbacks.map(fn => fn()) // 配合step4 没有直接传参数了
            }          
          })
        }

        const reject = (val) => {
          if((typeof val === 'object' || typeof val === 'function') && val.then){// 处理step8
            promiseResolveProcedure(this,val,resolve,reject)
            return // 后面不再执行
          }
          setTimeout(() => { // step2 源码中添加定时器之后，可以直接使用resolve('data')
            if(this.status === PENDING){ // step3 ：如果不是pending状态进来的，就不做处理，防止多个resolve执行
              this.status = REJECTED
              this.value = val
              // 执行所有的then方法
              this.rejectCallbacks.map(fn => fn()) // 配合step4 没有直接传参数了
            }          
          })
        }

        fn(resolve,reject)
      }

      // 方法
      then(onFulfilled = val => val , onRejected = err => {
        throw new Error(err)
      }){ // step5 支持透传，给一个默认参数（将原来的参数传递给下一个，下一个，都可以）
        let promise2 = null
        // 处理已经完成**成功 的promise
        if(this.status === FULFILLED){
          promise2 = new MyPromise((resolve,reject) => {
            const x = onFulfilled(this.value)
            promiseResolveProcedure(promise2,x,resolve,reject)
          })
          // return promise2
        }

        // 处理已经完成**失败 的promise
        if(this.status === REJECTED){
          promise2 = new MyPromise((resolve,reject) => {
            const x = onRejected(this.value)
            promiseResolveProcedure(promise2,x,resolve,reject)
          })
          // return promise2
        }


        // 处理尚未完成的promise
        if(this.status === PENDING){ // step3 ：如果不是pending状态进来的，就不做处理，防止多个resolve执行
          promise2 = new MyPromise((resolve,reject) => { // step4 then方法返回 新的promise 以支持链式调用

            this.resolvedCallbacks.push(()=>{
              const x = onFulfilled(this.value)
              // resolve(x) // 传递数据到下一个then
              promiseResolveProcedure(promise2,x,resolve,reject)
            })          

            this.rejectCallbacks.push(()=>{
              const x = onRejected(this.value)
              // resolve(x) // 传递数据到下一个then
              promiseResolveProcedure(promise2,x,resolve,reject)
            }) 
          })
          // return promise2
        } 
        // 三种状态下，可以公用的返回值
        return promise2      
      }
    }

    // MyPromise.all() // 静态方法自动执行 
  </script>

  <script>
    // 自定义mypromise测试

    // 第一步：step 1 
    // const promise = new MyPromise((resolve,reject) => {
    //   setTimeout(() => {
    //     // 获取ajax
    //     resolve('step1')
    //   },1000)
    // }).then(data => {
    //   console.log('获取自定义的数据：',data)
    // })


    // 第一步：step 2 
    // const promise = new MyPromise((resolve,reject) => {
    //   resolve('step2')
    // }).then(data => {
    //   console.log('获取自定义的数据：',data)
    // })

    // // step 3 // 规范中只能执行第一次的，后面的不再执行
    // const promise = new MyPromise((resolve,reject) => {
    //   resolve('step3')
    //   resolve('step3.1')
    // }).then(data => {
    //   console.log('获取自定义的数据：',data)
    // })

    // // step 4 // 支持多个then() 链式调用
    // const promise = new MyPromise((resolve,reject) => {
    //   resolve('step4')
    // }).then(data => {
    //   console.log('获取自定义的数据：',data)
    //   return 'step 4.1'
    // }).then(data => {
    //   console.log('链式调用then：',data)
    // })

    //  // step 5 // 支持空then调用
    //  const promise = new MyPromise((resolve,reject) => {
    //   resolve('step5')
    // }).then(data => {
    //   console.log('获取自定义的数据：',data)
    //   return 'step 5.1'
    // })
    // .then()
    // .then(data => {
    //   console.log('链式调用then：',data)
    // })

    // // step 6 // 支持空thenable调用
    // const promise = new MyPromise((resolve,reject) => {
    //   resolve('step6')
    // }).then(data => {
    //   console.log('获取自定义的数据：',data)
    //   return {
    //     then(r,j){  // thenable对象
    //       r('step6.1')
    //     }
    //   }
    // })
    // .then(data => {
    //   console.log('链式调用then6.1--thenable功能：',data)
    // })

    // // step 7 // 支持返回promise对象
    // const promise = new MyPromise((resolve,reject) => {
    //   resolve('step7')
    // }).then(data => {
    //   console.log('获取自定义的数据：',data)
    //   return new MyPromise((resolve) => {
    //     resolve('step 7.1')
    //   })
    // })
    // .then(data => {
    //   console.log('支持返回promise对象：',data)
    // })

    // // step 8 // 支持返回promise对象
    // const promise = new MyPromise((resolve,reject) => {
    //   resolve(
    //     new MyPromise((resolve) => {
    //     resolve('step 8')
    //   })
    //   ) 
    // })
    // .then(data => {
    //   console.log('获取数据：',data)
    // })

       // step 9 // 处理 then 中的循环 promise。
       // 原生的promise   抛出错误
       // promise.html:1 Uncaught (in promise) TypeError: Chaining cycle detected for promise #<Promise>
       // Promise.then (async)
       // (anonymous) @ promise.html:191
      // const promise = new MyPromise((resolve,reject) => {
      //   resolve('step 9') 
      // })
      // const promise1 = promise.then(data => {
      //   return promise1
      // })

      // step 10 promise.all 静态方法
      // MyPromise.all([
      //   new MyPromise(resolve => {
      //     resolve(1)
      //   }),
      //   new MyPromise(resolve => {
      //     resolve(2)
      //   })
      // ]).then(dataList => {
      //   console.log('获取多个promise返回的数组：',dataList)
      // })

      
      //  // step 11 // 支持 reject 和  catch。
      // const promise = new MyPromise((resolve,reject) => {
      //   reject('step 11') 
      // }).then(
      //   data => {
      //     console.log('resolve:',data)
      //   },
      //   rej => {
      //     console.log('reject:',rej)
      //   }
      // )

      // step 12 // 支持 处理 完成态 或者 失败态的then。
      // 测试原生的不好使   
      const promise = new MyPromise((resolve,reject) => {
        resolve('step 12') 
      })
      setTimeout(()=>{
        promise.then(
          data => {
            console.log('resolve12:',data)
          }  
        )
        promise.then(
          data => {
            console.log('resolve12:',data)
          }  
        )
      },1000)

      
     



  </script>
  <script>

    // // 步骤1
    // new Promise((resolve,reject) => {
    //   setTimeout(() => {
    //     // ajax获取数据
    //     resolve('step1')
    //   },1500)
    // }).then(data => {
    //   console.log('获取到数据：',data)
    // })
  </script>
</body>
</html>